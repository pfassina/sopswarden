{
  secretsFile,
  sopsFile,
  ageKeyFile,
  sopsConfigFile,
  rbwCommand,
  forceSync,
  workingDirectory,
}: ''
  #!/usr/bin/env bash
  # sopswarden-sync - Sync secrets from Bitwarden to encrypted sops file
  # Generated by sopswarden flake

  set -euo pipefail

  # Configuration
  SECRETS_FILE="${secretsFile}"
  SOPS_FILE="${sopsFile}"
  AGE_KEY_FILE="${ageKeyFile}"
  SOPS_CONFIG_FILE="${sopsConfigFile}"
  RBW_COMMAND="${rbwCommand}"
  FORCE_SYNC=''${FORCE_SYNC:-${
    if forceSync
    then "true"
    else "false"
  }}

  # Working directory setup
  ${
    if workingDirectory != null
    then ''
      WORK_DIR="${workingDirectory}"
      cd "$WORK_DIR"
    ''
    else ''
      # Detect if secrets file is in Nix store and use runtime directory instead
      if [[ "$SECRETS_FILE" == /nix/store/* ]]; then
          # Try to find the actual NixOS configuration directory
          # Look for common patterns: flake.nix, configuration.nix, or secrets directory
          WORK_DIR="$(pwd)"
          
          # If we're not in a directory with NixOS config files, try some common locations
          if [[ ! -f "$WORK_DIR/flake.nix" && ! -f "$WORK_DIR/configuration.nix" ]]; then
              for candidate in "$HOME/nix" "$HOME/.config/nixos" "$HOME/nixos" "$PWD"; do
                  if [[ -f "$candidate/flake.nix" || -f "$candidate/configuration.nix" || -d "$candidate/secrets" ]]; then
                      WORK_DIR="$candidate"
                      break
                  fi
              done
          fi
          
          echo "ğŸ”§ Detected Nix store secrets file, using runtime directory: $WORK_DIR"
      else
          # Original behavior for non-Nix environments
          WORK_DIR="$(dirname "$(realpath "$SECRETS_FILE")")"
      fi
      cd "$WORK_DIR"
    ''
  }

  # Resolve relative paths from working directory
  SECRETS_FILE="$(realpath "$SECRETS_FILE")"
  
  # Handle SOPS_FILE: if it's a Nix store path, write to working directory instead
  if [[ "$SOPS_FILE" == /nix/store/* ]]; then
      # Extract actual filename by removing Nix store hash prefix
      nix_filename="$(basename "$SOPS_FILE")"
      actual_filename="''${nix_filename#*-}"  # Remove everything up to and including first dash
      SOPS_FILE="$WORK_DIR/$actual_filename"
      echo "ğŸ”§ Detected Nix store path, writing to: $SOPS_FILE"
  else
      SOPS_FILE="$(realpath "$SOPS_FILE")"
  fi
  
  HASH_FILE="$(dirname "$SECRETS_FILE")/.last-sync-hash"

  # Check if secrets.nix has changed since last sync
  SECRETS_HASH=$(sha256sum "$SECRETS_FILE" 2>/dev/null | cut -d' ' -f1 || echo "no-hash")

  if [ "$FORCE_SYNC" != "true" ] && [ -f "$HASH_FILE" ] && [ "$(cat "$HASH_FILE")" = "$SECRETS_HASH" ]; then
      echo "âœ… secrets.nix unchanged since last sync, skipping..."
      echo "ğŸ’¡ Use FORCE_SYNC=true to force a sync anyway"
      exit 0
  fi

  # Check dependencies
  check_dependency() {
      if ! command -v "$1" &> /dev/null; then
          echo "Error: $1 is not installed. Please install it first."
          exit 1
      fi
  }

  check_dependency "${builtins.baseNameOf rbwCommand}"
  check_dependency "sops"
  check_dependency "age"
  check_dependency "jq"
  check_dependency "nix"

  # Test rbw authentication with graceful error handling
  if ! $RBW_COMMAND ls &> /dev/null; then
      echo "âŒ Error: rbw is not authenticated or vault is locked."
      echo "ğŸ”“ Please run '$RBW_COMMAND unlock' first."
      echo "ğŸ’¡ If using a self-hosted server, make sure rbw is configured:"
      echo "   rbw config set base_url https://your-server.com"
      echo "   rbw config set email your-email@example.com"
      exit 1
  fi

  echo "ğŸ”„ Syncing secrets from Bitwarden..."

  # Read secrets.nix and extract secret definitions using nix
  secret_keys=$(nix eval --impure --raw --expr "
    let secrets = (import $SECRETS_FILE).secrets;
    in builtins.concatStringsSep \" \" (builtins.attrNames secrets)")

  if [ -z "$secret_keys" ]; then
      echo "âš ï¸  No secrets found in $SECRETS_FILE"
      exit 1
  fi

  # Create temporary unencrypted YAML
  temp_file=$(mktemp)
  echo "# Auto-generated by sopswarden - $(date)" > "$temp_file"
  echo "# Source: $SECRETS_FILE" >> "$temp_file"

  for key in $secret_keys; do
      echo "ğŸ“¡ Fetching: $key"

      # Get the secret definition (either string or attrset)
      secret_def=$(nix eval --impure --raw --expr "
          let
            secrets = (import $SECRETS_FILE).secrets;
            def = secrets.$key;
          in
            if builtins.isString def then
              builtins.toJSON { name = def; user = null; type = \"login\"; field = \"password\"; }
            else
              builtins.toJSON (def // { type = def.type or \"login\"; field = def.field or \"password\"; })")

      # Parse the JSON to get all fields
      name=$(echo "$secret_def" | jq -r '.name')
      user=$(echo "$secret_def" | jq -r '.user // empty')
      item_type=$(echo "$secret_def" | jq -r '.type // "login"')
      field=$(echo "$secret_def" | jq -r '.field // "password"')

      # Fetch from bitwarden based on type
      if [ "$item_type" = "note" ]; then
          # For secure notes, use --field to get specific field
          if ! secret_value=$($RBW_COMMAND get "$name" --field "$field" 2>/dev/null); then
              echo "âŒ Failed to fetch note '$name' field '$field'"
              exit 1
          fi
      elif [ -n "$user" ]; then
          # For login items with specific user
          if [ "$field" = "password" ]; then
              if ! secret_value=$($RBW_COMMAND get "$name" "$user" 2>/dev/null); then
                  echo "âŒ Failed to fetch login '$name' for user '$user'"
                  exit 1
              fi
          else
              if ! secret_value=$($RBW_COMMAND get "$name" "$user" --field "$field" 2>/dev/null); then
                  echo "âŒ Failed to fetch login '$name' field '$field' for user '$user'"
                  exit 1
              fi
          fi
      else
          # For login items without specific user
          if [ "$field" = "password" ]; then
              if ! secret_value=$($RBW_COMMAND get "$name" 2>/dev/null); then
                  echo "âŒ Failed to fetch login '$name'"
                  exit 1
              fi
          else
              if ! secret_value=$($RBW_COMMAND get "$name" --field "$field" 2>/dev/null); then
                  echo "âŒ Failed to fetch login '$name' field '$field'"
                  exit 1
              fi
          fi
      fi

      # Add to YAML (properly escape for YAML)
      escaped_value=$(echo "$secret_value" | sed 's/"/\\"/g')
      echo "$key: \"$escaped_value\"" >> "$temp_file"
  done

  # Encrypt with sops
  if [ -f "$SOPS_FILE" ]; then
      echo "ğŸ”’ Updating existing encrypted secrets file..."
  else
      echo "ğŸ”’ Creating new encrypted secrets file..."
  fi

  # Create temporary directory for encryption to avoid Nix store write issues
  TEMP_DIR=$(mktemp -d)
  temp_yaml="$TEMP_DIR/secrets.yaml"
  cleanup() {
      rm -rf "$TEMP_DIR"
  }
  trap cleanup EXIT

  # Copy temp file and sops config to temporary directory
  cp "$temp_file" "$temp_yaml"
  cp "$SOPS_CONFIG_FILE" "$TEMP_DIR/.sops.yaml"
  rm "$temp_file"

  # Change to temporary directory and encrypt
  cd "$TEMP_DIR"
  if ! sops --encrypt secrets.yaml > "$SOPS_FILE"; then
      echo "âŒ Failed to encrypt secrets with sops"
      exit 1
  fi

  # Update the hash file to track this sync
  echo "$SECRETS_HASH" > "$HASH_FILE"

  echo "âœ… Secrets synced successfully to $SOPS_FILE"
  echo "ğŸ“ Encrypted $(echo "$secret_keys" | wc -w) secrets from Bitwarden"
  echo "ğŸ’¡ Remember to commit the updated secrets file to your repository"
''
